<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Oscars — Nominations (2000–2025)</title>

  <style>
    :root{--bg:#0f172a;--card:#0b1220;--muted:#9aa4b2;--accent:#f59e0b}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; margin:0;background:linear-gradient(180deg,#071029 0%, #07121a 100%);color:#e6eef6}
    header{padding:20px 24px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;gap:16px;align-items:center}
    h1{margin:0;font-size:20px}
    .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
    select,input{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:inherit}
    main{padding:18px;display:grid;grid-template-columns:260px 1fr;gap:18px}
    aside{background:rgba(255,255,255,0.02);padding:12px;border-radius:12px}
    .year-list{display:flex;flex-direction:column;gap:6px;max-height:70vh;overflow:auto;padding-right:6px}
    .year-item{padding:8px;border-radius:8px;cursor:pointer}
    .year-item.active{background:linear-gradient(90deg,#142534,#0b2536);box-shadow:0 4px 14px rgba(0,0,0,0.6)}
    .content{background:rgba(255,255,255,0.01);padding:16px;border-radius:12px;min-height:70vh;overflow:auto}
    .category{margin-bottom:18px;padding-bottom:10px;border-bottom:1px dashed rgba(255,255,255,0.03)}
    .cat-title{display:flex;justify-content:space-between;align-items:center}
    .nominees{margin-top:8px;display:flex;flex-direction:column;gap:6px}
    .nominee{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .winner{background:linear-gradient(90deg,rgba(245,158,11,0.12),rgba(245,158,11,0.03));border:1px solid rgba(245,158,11,0.12)}
    footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    button{background:var(--accent);color:#04201b;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    .busy{opacity:0.6}
    pre{white-space:pre-wrap}
  </style>
</head>

<body>

<header>
    <div>
      <h1>Oscars — Nominations (2000–2025)</h1>
      <div class="small">Data fetched live from Wikipedia (MediaWiki API) — ceremony pages 2000→2025.</div>
    </div>

    <div class="controls">
      <input id="search" placeholder="Filter categories or nominees..." />
      <button id="exportJson">Export JSON</button>
    </div>
  </header>

  <main>
    <aside>
      <div class="small" style="margin-bottom:8px">Select a ceremony year</div>
      <div class="year-list" id="yearList"></div>
      <div style="margin-top:12px" class="small">Tip: data is cached in your browser for faster browsing.</div>
    </aside>

    <section class="content" id="content">
      <div id="status" class="small">Choose a year to load nominations.</div>
      <div id="results"></div>
    </section>
  </main>

  <footer>
    Built with ❤️ — fetches Wikipedia ceremony pages for each year and extracts the "Winners and nominees" section.
  </footer>

<script>
    
      
    document.querySelector('.year-item').click();
  </script>

</body>
</html>

function extractWinnersAndNominees(html){
  // More tolerant parser: look for several possible headings and gather nearby lists/tables/paragraphs
  const parser = new DOMParser();
  const doc = parser.parseFromString(html,'text/html');

  // candidate headline text patterns (order matters — common ones first)
  const headlinePatterns = [
    /\bWinners\s*and\s*nominees\b/i,
    /\bWinners\b/i,
    /\bNominees\b/i,
    /\bNominations\b/i,
    /\bWinners\s*and\s*Nominees/i,
    /\bAwards\b/i
  ];

  // gather all mw-headline spans and plain headings to search
  const headlines = Array.from(doc.querySelectorAll('span.mw-headline, h2, h3, h4')).map(h=>{
    return {el: h, text: (h.textContent||'').trim()};
  });

  // find the first matching headline by any pattern
  let targetEntry = null;
  for(const p of headlinePatterns){
    targetEntry = headlines.find(h => p.test(h.text));
    if(targetEntry) break;
  }

  // fallback: if not found, try headings that contain 'nominee' or 'winner' words
  if(!targetEntry){
    targetEntry = headlines.find(h => /\b(nominee|winner|selection)\b/i.test(h.text));
  }

  // final fallback: use the first large section that contains ULs or tables
  if(!targetEntry){
    const bigSection = doc.querySelector('h2, h3, h4');
    if(bigSection){
      targetEntry = {el: bigSection, text: bigSection.textContent.trim()};
    }
  }

  if(!targetEntry) return {error:'Winners and nominees section not found on page'};

  // find the actual heading element (if span, get its closest heading parent)
  let sectionRoot = targetEntry.el.closest('h2, h3, h4') || targetEntry.el;

  const result = {categories:[]};

  // walk siblings until next h2 (or end)
  let node = sectionRoot.nextElementSibling;
  while(node && node.tagName && node.tagName.toLowerCase()!=='h2'){
    const tag = node.tagName.toLowerCase();

    // treat h3/h4 as category titles
    if(tag==='h3' || tag==='h4'){
      const catName = node.textContent.trim();
      const cat = {category:catName, nominees:[]};

      // collect following nodes (ul, table, p) until next heading of same/higher level
      let n2 = node.nextElementSibling;
      while(n2 && !/^h[1-4]$/.test(n2.tagName.toLowerCase())){
        const t2 = n2.tagName.toLowerCase();

        if(t2==='ul'){
          Array.from(n2.querySelectorAll('li')).forEach(li=>{
            const text = li.textContent.trim();
            const isWinner = /\(Winner\)|\bWinner\b|\bwon\b/i.test(li.innerHTML) || li.querySelector('.winner')!=null;
            if(text) cat.nominees.push({text, winner:isWinner});
          });
        } else if(t2==='table'){
          Array.from(n2.querySelectorAll('tr')).forEach(tr=>{
            const cols = Array.from(tr.querySelectorAll('td,th')).map(c=>c.textContent.trim()).filter(Boolean);
            if(cols.length){
              const text = cols.join(' — ');
              const isWinner = /winner/i.test(tr.textContent) || tr.querySelector('.winner')!=null;
              cat.nominees.push({text, winner:isWinner});
            }
          });
        } else if(t2==='p'){
          // paragraphs sometimes contain inline lists
          const lines = n2.textContent.split('\n').map(s=>s.trim()).filter(Boolean);
          lines.forEach(L=>{
            if(L.length>20){
              const isWinner = /\(Winner\)|\bWinner\b/i.test(L);
              cat.nominees.push({text:L, winner:isWinner});
            }
          });
        }
        n2 = n2.nextElementSibling;
      }

      result.categories.push(cat);
      node = n2;
      continue;
    }

    // if we hit a UL directly under the main section (some pages use direct lists)
    if(tag==='ul'){
      // create a generic category if none yet
      const cat = {category: sectionRoot.textContent.trim() || 'Nominees', nominees:[]};
      Array.from(node.querySelectorAll('li')).forEach(li=>{
        const text = li.textContent.trim();
        const isWinner = /\(Winner\)|\bWinner\b|\bwon\b/i.test(li.innerHTML) || li.querySelector('.winner')!=null;
        if(text) cat.nominees.push({text, winner:isWinner});
      });
      result.categories.push(cat);
      node = node.nextElementSibling;
      continue;
    }

    // if we see a table directly, treat similarly
    if(tag==='table'){
      const cat = {category: sectionRoot.textContent.trim() || 'Nominees', nominees:[]};
      Array.from(node.querySelectorAll('tr')).forEach(tr=>{
        const cols = Array.from(tr.querySelectorAll('td,th')).map(c=>c.textContent.trim()).filter(Boolean);
        if(cols.length){
          const text = cols.join(' — ');
          const isWinner = /winner/i.test(tr.textContent) || tr.querySelector('.winner')!=null;
          cat.nominees.push({text, winner:isWinner});
        }
      });
      result.categories.push(cat);
      node = node.nextElementSibling;
      continue;
    }

    node = node.nextElementSibling;
  }

  // Clean up: remove empty categories
  result.categories = result.categories.filter(c => c.nominees && c.nominees.length);

  if(!result.categories.length){
    return {error:'No nominees found in the detected section'};
  }
  return result;
}
